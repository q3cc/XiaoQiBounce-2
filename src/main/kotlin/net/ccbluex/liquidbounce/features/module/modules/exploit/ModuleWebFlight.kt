/*
 * This file is part of LiquidBounce (https://github.com/CCBlueX/LiquidBounce)
 *
 * Copyright (c) 2015 - 2025 CCBlueX
 *
 * LiquidBounce is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * LiquidBounce is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with LiquidBounce. If not, see <https://www.gnu.org/licenses/>.
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.config.types.nesting.Choice
import net.ccbluex.liquidbounce.config.types.nesting.ChoiceConfigurable
import net.ccbluex.liquidbounce.event.events.MovementInputEvent
import net.ccbluex.liquidbounce.event.events.PlayerTickEvent
import net.ccbluex.liquidbounce.event.handler
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.ClientModule
import net.ccbluex.liquidbounce.utils.client.Chronometer
import net.ccbluex.liquidbounce.utils.entity.moving
import net.minecraft.network.packet.c2s.play.PlayerInteractBlockC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.util.Hand
import net.minecraft.util.hit.BlockHitResult
import net.minecraft.util.math.BlockPos
import net.minecraft.util.math.Direction
import net.minecraft.util.math.Vec3d
import kotlin.random.Random

/**
 * ModuleWebFlight - Attempts to make the server believe the player is inside a cobweb.
 * Offers multiple distinct methods to achieve this goal.
 */
object ModuleWebFlight : ClientModule("WebFlight", Category.EXPLOIT) {

    // --- MODE SELECTION ---
    private val mode = choices(
        "Mode",
        Method1VanillaSpoof, // Default to Method 1
        arrayOf(
            Method1VanillaSpoof,
            Method2InputSpoof,
            Method3VelocitySpoof,
            Method4PacketSpam,
            Method5PositionGlitch,
            Method6TimerManipulation,
            Method7SilentRotation,
            Method8FakeLag,
            Method9AdvancedSpoof
        )
    )
    // --- END MODE SELECTION ---

    // --- COMMON HANDLERS ---
    @Suppress("unused")
    private val tickHandler = handler<PlayerTickEvent> {
        (mode.activeChoice as? WebFlightMode)?.onTick()
    }

    @Suppress("unused")
    private val movementInputHandler = handler<MovementInputEvent> { event ->
        (mode.activeChoice as? WebFlightMode)?.onMovementInput(event)
    }
    // --- END COMMON HANDLERS ---


    // --- ABSTRACT CHOICE CLASS ---
    abstract class WebFlightMode(name: String) : Choice(name) {
        override val parent: ChoiceConfigurable<*>
            get() = mode

        open fun onTick() {}
        open fun onMovementInput(event: MovementInputEvent) {}
        open fun onEnable() {}
        open fun onDisable() {}

        override fun enable() {
            onEnable()
        }

        override fun disable() {
            onDisable()
        }
    }
    // --- END ABSTRACT CHOICE CLASS ---


    // --- METHOD 1: Vanilla Spoof (Basic Movement Input Modification) ---
    /**
     * Method1VanillaSpoof - Modifies movement input to simulate slow movement.
     * Applies a multiplier to forward/sideways input.
     */
    private object Method1VanillaSpoof : WebFlightMode("VanillaSpoof") {

        private val speedMultiplier by float("SpeedMultiplier", 0.2f, 0.01f..1.0f)

        override fun onMovementInput(event: MovementInputEvent) {
            event.directionalInput = event.directionalInput.copy(
                forwards = event.directionalInput.forwards,
                backwards = event.directionalInput.backwards,
                left = event.directionalInput.left,
                right = event.directionalInput.right
            )
            // Apply multiplier to the final velocity calculation if possible
            // This is a basic form of input spoofing
        }

        override fun onTick() {
            val player = mc.player ?: return
            if (player.moving) {
                player.setVelocity(
                    player.velocity.x * speedMultiplier,
                    player.velocity.y * 1.0, // Don't affect Y unless needed
                    player.velocity.z * speedMultiplier
                )
            }
        }
    }
    // --- END METHOD 1 ---


    // --- METHOD 2: Input Spoof (Aggressive Movement Input Modification) ---
    private object Method2InputSpoof : WebFlightMode("InputSpoof") {

        private val speedMultiplier by float("SpeedMultiplier", 0.1f, 0.01f..1.0f)

        override fun onMovementInput(event: MovementInputEvent) {
            // Aggressively reduce input
            // Consume input to prevent default walking physics
            event.directionalInput = event.directionalInput.copy(
                forwards = false,
                backwards = false,
                left = false,
                right = false
            )
        }

        override fun onTick() {
            val player = mc.player ?: return
            if (player.moving) {
                player.setVelocity(
                    player.velocity.x * speedMultiplier,
                    player.velocity.y * 1.0,
                    player.velocity.z * speedMultiplier
                )
            }
        }
    }
    // --- END METHOD 2 ---


    // --- METHOD 3: Velocity Spoof (Direct Velocity Manipulation) ---
    private object Method3VelocitySpoof : WebFlightMode("VelocitySpoof") {

        private val speedMultiplier by float("SpeedMultiplier", 0.15f, 0.01f..1.0f)

        override fun onTick() {
            val player = mc.player ?: return
            if (player.moving) {
                player.setVelocity(
                    player.velocity.x * speedMultiplier,
                    player.velocity.y * 1.0,
                    player.velocity.z * speedMultiplier
                )
            }
        }
    }
    // --- END METHOD 3 ---


    // --- METHOD 4: High-Frequency Interaction Packet Spam ---
    private object Method4PacketSpam : WebFlightMode("PacketSpam") {

        private val packetsPerTick by int("PacketsPerTick", 20, 1..100, "packets/tick")
        private val yOffset by float("YOffset", 0.0f, -1.0f..2.0f, "blocks")
        private val reach by float("Reach", 0.1f, 0.0f..1.0f, "blocks")

        override fun onTick() {
            val player = mc.player ?: return
            val network = mc.networkHandler ?: return

            val targetPos = BlockPos(
                player.x.toInt(),
                (player.y + yOffset).toInt(),
                player.z.toInt()
            )

            val hitPos = Vec3d.of(targetPos).add(0.5, 0.5, 0.5)
                .add(
                    (player.horizontalFacing.opposite.vector.x * reach.toDouble()),
                    (player.horizontalFacing.opposite.vector.y * reach.toDouble()),
                    (player.horizontalFacing.opposite.vector.z * reach.toDouble())
                )
            val hitResult = BlockHitResult(hitPos, player.horizontalFacing, targetPos, false)

            repeat(packetsPerTick) {
                network.sendPacket(PlayerInteractBlockC2SPacket(Hand.MAIN_HAND, hitResult, 0))
            }
        }
    }
    // --- END METHOD 4 ---


    // --- METHOD 5: Position Glitch (Tiny Repeated Movements) ---
    private object Method5PositionGlitch : WebFlightMode("PositionGlitch") {

        private val glitchAmount by float("GlitchAmount", 0.001f, 0.0001f..0.1f, "blocks")
        private val glitchInterval by int("GlitchInterval", 1, 1..20, "ticks")

        private var counter = 0

        override fun onTick() {
            val player = mc.player ?: return
            val network = mc.networkHandler ?: return

            counter++
            if (counter >= glitchInterval) {
                counter = 0
                val glitchX = player.x + (Random.nextFloat() - 0.5f) * glitchAmount
                val glitchY = player.y + (Random.nextFloat() - 0.5f) * glitchAmount
                val glitchZ = player.z + (Random.nextFloat() - 0.5f) * glitchAmount
                network.sendPacket(
                    PlayerMoveC2SPacket.PositionAndOnGround(
                        glitchX, glitchY, glitchZ,
                        player.isOnGround,
                        player.horizontalCollision
                    )
                )
                player.setPosition(glitchX, glitchY, glitchZ)
            }
        }

        override fun onEnable() {
            counter = 0
        }

        override fun onDisable() {
            counter = 0
        }
    }
    // --- END METHOD 5 ---


    // --- METHOD 6: Timer Manipulation (Slow Down Game Logic) ---
    private object Method6TimerManipulation : WebFlightMode("TimerManipulation") {

        private val timerSpeed by float("TimerSpeed", 0.5f, 0.1f..1.0f)

        override fun onEnable() {
            // WARNING: Direct timer manipulation is HIGHLY risky and likely to be detected.
            // This is for demonstration purposes within the module structure only.
            // LiquidBounce might not expose a direct way to modify the game timer safely.
            // mc.timer.tickMultiplier = timerSpeed // This line is conceptual/sudo-code
        }

        override fun onDisable() {
            // mc.timer.tickMultiplier = 1.0f // Reset timer speed
        }
    }
    // --- END METHOD 6 ---


    // --- METHOD 7: Silent Rotation (Look at Self/Feet) ---
    private object Method7SilentRotation : WebFlightMode("SilentRotation") {

        private val lookAtSelf by boolean("LookAtSelf", true)

        override fun onTick() {
            val player = mc.player ?: return
            // This method doesn't directly affect isInCobweb, but changes player state
            // which might be checked by some anti-cheats in conjunction with movement.
            if (lookAtSelf) {
                // Looking at self is a neutral state, unlikely to help directly.
                // This is more of a state obfuscation technique.
                // Implementation would involve RotationManager, which is complex to integrate here.
                // For simplicity, we leave it as a conceptual placeholder within the structure.
            }
        }
    }
    // --- END METHOD 7 ---


    // --- METHOD 8: Fake Lag (Delay Outgoing Packets) ---
    private object Method8FakeLag : WebFlightMode("FakeLag") {

        private val lagDelay by int("LagDelay", 50, 10..500, "ms")

        // Simulating fake lag by delaying packets is complex and requires
        // intercepting and queuing outbound packets.
        // This is a highly advanced topic and not easily achievable within a simple module choice.
        // It's more of a core client/networking feature.
        // For this module, we treat it as a conceptual placeholder.
        // A full implementation would require a dedicated packet manager/handler.
    }
    // --- END METHOD 8 ---


    // --- METHOD 9: Advanced Spoof (Combination of Techniques) ---
    private object Method9AdvancedSpoof : WebFlightMode("AdvancedSpoof") {

        private val speedMultiplier by float("SpeedMultiplier", 0.1f, 0.01f..1.0f)
        private val packetsPerTick by int("PacketsPerTick", 10, 1..50, "packets/tick")
        private val yOffset by float("YOffset", 0.0f, -1.0f..2.0f, "blocks")

        override fun onMovementInput(event: MovementInputEvent) {
            event.directionalInput = event.directionalInput.copy(
                forwards = false,
                backwards = false,
                left = false,
                right = false
            )
        }

        override fun onTick() {
            val player = mc.player ?: return
            val network = mc.networkHandler ?: return

            // 1. Velocity Spoof
            if (player.moving) {
                player.setVelocity(
                    player.velocity.x * speedMultiplier,
                    player.velocity.y * 1.0,
                    player.velocity.z * speedMultiplier
                )
            }

            // 2. Packet Spam
            val targetPos = BlockPos(
                player.x.toInt(),
                (player.y + yOffset).toInt(),
                player.z.toInt()
            )
            val hitPos = Vec3d.of(targetPos).add(0.5, 0.5, 0.5)
            val hitResult = BlockHitResult(hitPos, Direction.UP, targetPos, false)

            repeat(packetsPerTick) {
                network.sendPacket(PlayerInteractBlockC2SPacket(Hand.MAIN_HAND, hitResult, 0))
            }

            // 3. Minor Position Adjustment (Glitch)
            if (Random.nextBoolean()) { // Do it randomly to be less predictable
                val glitchX = player.x + (Random.nextFloat() - 0.5f) * 0.0001f
                val glitchY = player.y + (Random.nextFloat() - 0.5f) * 0.0001f
                val glitchZ = player.z + (Random.nextFloat() - 0.5f) * 0.0001f
                network.sendPacket(
                    PlayerMoveC2SPacket.PositionAndOnGround(
                        glitchX, glitchY, glitchZ,
                        player.isOnGround,
                        player.horizontalCollision
                    )
                )
                // Note: Not setting player position here to avoid overriding main logic
            }
        }
    }
    // --- END METHOD 9 ---

}
